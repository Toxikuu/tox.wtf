{% extends "base.html" %}

{% block header %}
    {{ macros.pwd(["code", "tinaries", "clear.asm"]) }}
{% endblock %}

{% block content %}
<p>::: exceedingly cute x86_64 assembly clear implementation, featuring a custom
elf header</p>

<p>
there was literally no reason to do this. i just wanted to see how small i could
make my pause implementation. the answer is pretty fucking small (157 bytes).
like smaller than its source (1010 bytes).

huge thanks to https://nathanotterness.com/2021/10/tiny_elf_modernized.html
</p>

{% raw %}
<pre>
<code>
; clear.asm (x86_64) - the cutest possible(?) implementation of clear
;
; licensing:
;   do whatever the fuck you want
;   im not involved
;
; assemble using:
;   nasm -f bin clear.asm -o /dev/stdout | install -vm755 /dev/stdin clear
;
; -- tox
[bits 64]

file_load_va: equ 4096 * 40

db 0x7f, 'E', 'L', 'F'
db 2
db 1
db 1
db 0
dq 0
dw 2
dw 0x3e
dd 1

dq entry_point + file_load_va
dq program_headers_start

dq 0
dd 0
dw 64
dw 0x38
dw 1
dw 0x40
dw 0
dw 0

program_headers_start:
dd 1
dd 5
dq 0
dq file_load_va
dq file_load_va
dq file_end
dq file_end
dq 0x200000

section .rodata
msg:        db      0x1b, '[', 'H', 0x1B, '[', 'J', ; \x1b[H\x1b[J
len         equ     $-msg

entry_point:
    mov     eax,    1           ; sys_write

    xor     edi,    edi         ; fd 1 (stdout)
    inc     edi

    lea     esi,    [rel msg]   ; address of message
    mov     edx,    len         ; length
    syscall

    mov     eax,    60          ; sys_exit
    xor     edi,    edi         ; code 0
    syscall

file_end:
</code>
</pre>
{% endraw %}

{% endblock %}
